{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Gufo ACME","text":"<p>Gufo ACME is a Python asyncio client for the ACME protocol.</p> <p>The Automatic Certificate Management Environment (ACME) protocol defines a method for automated certificate signing, now widely used by services such as Let's Encrypt. Gufo ACME is a Python asyncio ACME client library that simplifies the protocol complexity with a straightforward and robust API.</p> <p>Gufo ACME contains various clients which can be applied to your tasks:</p> <ul> <li>AcmeClient - base client to implement any fulfillment functionality     by creating subclasses.</li> <li>DavAcmeClient - http-01 fulfillment using WebDAV methods.</li> <li>PowerDnsAcmeClient - dns-01 PowerDNS fulfillment.</li> <li>WebAcmeClient - http-01 static file fulfillment.</li> </ul>"},{"location":"#supported-certificate-authorities","title":"Supported Certificate Authorities","text":"<ul> <li>Letsencrypt</li> <li>ZeroSSL</li> <li>Google Public CA</li> <li>Any RFC-8555 compatible CA.</li> </ul>"},{"location":"#examples","title":"Examples","text":""},{"location":"#account-creation","title":"Account Creation","text":"<p>Create an account and store state to the file. <pre><code>client_key = AcmeClient.get_key()\nasync with AcmeClient(DIRECTORY, key=client_key) as client:\n    await client.new_account(email)\n    state = client.get_state()\nwith open(client_state_path, \"wb\") as fp:\n    fp.write(state)\n</code></pre></p>"},{"location":"#private-key-generation","title":"Private Key Generation","text":"<p>To generate a private key in PEM format. <pre><code>private_key = AcmeClient.get_domain_private_key()\n</code></pre></p>"},{"location":"#generate-csr","title":"Generate CSR","text":"<p>To generate a certificate signing request. <pre><code>csr = AcmeClient.get_domain_csr(domain, private_key)\n</code></pre></p>"},{"location":"#sign-certificate","title":"Sign Certificate","text":"<p>Sign the certificate using <code>http-01</code> challenge:</p> <pre><code>CHALLENGE_DIR = \"/www/acme/\"\n\n\nclass SignAcmeClient(AcmeClient):\n    async def fulfill_http_01(\n        self, domain: str, challenge: AcmeChallenge\n    ) -&gt; bool:\n        v = self.get_key_authorization(challenge)\n        with open(os.path.join(CHALLENGE_DIR, challenge.token), \"wb\") as fp:\n            fp.write(v)\n        return True\n\n    async def clear_http_01(\n        self: AcmeClient, domain: str, challenge: AcmeChallenge\n    ) -&gt; None:\n        os.unlink(os.path.join(CHALLENGE_DIR, challenge.token))\n\n    ...\nasync with SignAcmeClient.from_state(state) as client:\n    cert = await client.sign(domain, csr)\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Pure-Python implementation.</li> <li>Asynchronous.</li> <li>Fully typed.</li> <li>Clean API.</li> <li>Built with security in mind.</li> <li>Robust well-tested code.</li> <li>99+% test coverage.</li> </ul>"},{"location":"#on-gufo-stack","title":"On Gufo Stack","text":"<p>This product is a part of Gufo Stack - the collaborative effort  led by Gufo Labs. Our goal is to create a robust and flexible  set of tools to create network management software and automate  routine administration tasks.</p> <p>To do this, we extract the key technologies that have proven themselves  in the NOC and bring them as separate packages. Then we work on API, performance tuning, documentation, and testing. The NOC uses the final result as the external dependencies.</p> <p>Gufo Stack makes the NOC better, and this is our primary task. But other products can benefit from Gufo Stack too. So we believe that our effort will make  the other network management products better.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p> <p>To see unreleased changes, please see the CHANGELOG on the master branch guide.</p>"},{"location":"CHANGELOG/#unreleased","title":"[Unreleased]","text":""},{"location":"CHANGELOG/#infrastructure","title":"Infrastructure","text":"<ul> <li>Codecov integration.</li> </ul>"},{"location":"CHANGELOG/#060-2025-09-14","title":"0.6.0 - 2025-09-14","text":""},{"location":"CHANGELOG/#security","title":"Security","text":"<ul> <li>Bump cryptography &gt;= 45.0.7 (due to security issues).</li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>josepy &gt;= 2.1.0</li> <li>httpx replaced with Gufo HTTP</li> </ul>"},{"location":"CHANGELOG/#051-2025-09-08","title":"0.5.1 - 2025-09-08","text":""},{"location":"CHANGELOG/#security_1","title":"Security","text":"<ul> <li>devcontainer: Install security patches.</li> <li>devcontainer: Use python:3.13-slim-trixie as base.</li> </ul>"},{"location":"CHANGELOG/#infrastructure_1","title":"Infrastructure","text":"<ul> <li>devcontainer: Bump IPython to 9.4.0.</li> </ul>"},{"location":"CHANGELOG/#050-2025-06-23","title":"0.5.0 - 2025-06-23","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>AcmeClient.get_self_signed_certificate funciton.</li> </ul>"},{"location":"CHANGELOG/#infrastructure_2","title":"Infrastructure","text":"<ul> <li>Replace black with ruff format.</li> <li>PYPI trusted publishing.</li> </ul>"},{"location":"CHANGELOG/#040-2023-11-23","title":"0.4.0 - 2023-11-23","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li><code>AcmeAuthorizationStatus</code> structure</li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li><code>AcmeClient.get_challenges</code> replaced with <code>AcmeClient.get_authorization_status</code>.</li> <li>Respond to challenges only if authorization status is <code>pending</code>.</li> </ul>"},{"location":"CHANGELOG/#030-2023-11-23","title":"0.3.0 - 2023-11-23","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>External Account Binding support.</li> </ul>"},{"location":"CHANGELOG/#020-2023-11-17","title":"0.2.0 - 2023-11-17","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>DavAcmeClient: http-01 fulfillment using WebDAV</li> <li>PowerDnsAcmeClient: dns-01 fulfillment using PowerDNS.</li> <li>WebAcmeClient: http-01 fulfillment using static files.</li> </ul>"},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>ACMEClient has been moved into <code>gufo.acme.clients.base</code>.</li> <li>ACMEClient, types, and exceptions have been renamed to snake-case.</li> </ul>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>Fixed typo in exception class name.</li> </ul>"},{"location":"CHANGELOG/#011-2023-11-16","title":"0.1.1 - 2023-11-16","text":""},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>Fixed <code>AcmeClient.from_state()</code> to return a proper subclass.</li> <li>Fixed type annotation for <code>AcmeClient.__aenter__()</code> in subclasses.</li> </ul>"},{"location":"CHANGELOG/#010-2023-11-15","title":"0.1.0 - 2023-11-15","text":"<ul> <li>Initial release.</li> </ul>"},{"location":"LICENSE/","title":"License","text":"<p>Copyright \u00a9 2023-2025, Gufo Labs. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li>Redistributions of source code must retain the above copyright notice,    this list of conditions and the following disclaimer.</li> <li>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</li> <li>Neither the name of Gufo Labs nor the names of its contributors may be used    to endorse or promote products derived from this software without    specific prior written permission.</li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"faq/","title":"FAQ","text":"<p>What is \"Gufo\"?</p> <p>Gufo means the Owl in Italian.</p> <p>Why the owls?</p> <p>We love owls and the viable parts of our technologies were proven at the project, named \"the Owl\".</p> <p>What is \"Gufo Labs\"?</p> <p>Gufo Labs is the Milan-based company specialized on network and IT consulting, and on software research.</p> <p>What is \"Gufo Stack\"?</p> <p>We've extracted core components behind the NOC  and released them as independent packages, available under the terms  of the 3-clause BSD license. Our software shares common code quality standards  and is battle-proven under the high load. We hope our key components will help  the engineers and the developers to build reliable networks and robust network  management software.  See more for details.</p>"},{"location":"installation/","title":"Installation","text":"<p>Install with the pip</p> <pre><code>$ pip install gufo_acme\n</code></pre>"},{"location":"installation/#checking-the-installation","title":"Checking the Installation","text":"<p>To check the installation just import the module</p> <pre><code>from gufo.acme import __version__\n</code></pre>"},{"location":"installation/#upgrading","title":"Upgrading","text":"<p>To upgrade existing Gufo ACME installation use pip</p> <pre><code>$ pip install --upgrade gufo_acme\n</code></pre>"},{"location":"installation/#uninstalling","title":"Uninstalling","text":"<p>To uninstall Gufo ACME use pip</p> <pre><code>$ pip uninstall gufo_acme\n</code></pre>"},{"location":"dev/","title":"Gufo ACME: Developer's Guide","text":"<p>This section is intended for Gufo ACME developers and for entities,  including both individuals and companies, interested in contributing to the project.</p> <ul> <li>Developer's Environment</li> <li>Building and Testing</li> <li>Common Tasks</li> <li>Code Quality</li> <li>Code Base</li> <li>Contributing Guide</li> <li>Code of Conduct</li> <li>Supported Standards</li> </ul>"},{"location":"dev/CODE_OF_CONDUCT/","title":"Gufo Stack Code of Conduct","text":"<p>Gufo Stack are the tools built by people for people. We aim to create a respectful, collaborative, and constructive community where everyone can contribute to building better software.</p>"},{"location":"dev/CODE_OF_CONDUCT/#the-rule","title":"The Rule","text":"<p>\u201cAnd as you wish that others would do to you, do so to them.\u201d</p> <p>-- Luke 6:31</p>"},{"location":"dev/CODE_OF_CONDUCT/#the-note","title":"The Note","text":"<p>This principle is universal. Similar wisdom can be found in many traditions:</p> <ul> <li>Confucius: \u201cDo not impose on others what you do not wish for yourself.\u201d (Analects 15:24)</li> <li>Prophet Muhammad (peace be upon him): \u201cNone of you [truly] believes until he loves for his brother what he loves for himself.\u201d (Hadith, Sahih Muslim 45:71)</li> </ul> <p>That\u2019s all.</p>"},{"location":"dev/CONTRIBUTING/","title":"Types of contributions","text":"<p>You can contribute to the Gufo Labs projects in several way. This repo is a place to discuss and collaborate on GitHub! Our team is maintaining this repo to preserve our bandwidth, off topic conversations will be closed.</p>"},{"location":"dev/CONTRIBUTING/#discussions","title":"Discussions","text":"<p>Discussions are where we have conversations.</p> <p>If you'd like help troubleshooting a PR you're working on, have a great new idea, or want to share something amazing you've learned in our docs, join us in discussions.</p>"},{"location":"dev/CONTRIBUTING/#issues","title":"Issues","text":"<p>Issues are used to track tasks that contributors can help with. </p> <p>If you've found bug, or something in the content of the documentation that should be updated, search open issues to see if someone else has reported the same thing. If it's something new, open an issue. We'll use the issue to have a conversation about the problem you want to fix.</p>"},{"location":"dev/CONTRIBUTING/#pull-requests","title":"Pull requests","text":"<p>A pull request is a way to suggest changes in our repository.</p>"},{"location":"dev/codebase/","title":"Project's Code Base","text":"<p>The code base of the project has following structure:</p> <ul> <li><code>.devcontainer/</code> - Developer's container configuration for    VSCode Remote Containers. Just reopen   project in remote container to get ready-to-development   environment.</li> <li> <p><code>.github/</code> - GitHub settings</p> <ul> <li><code>workflows/</code> - GitHub Actions Workflows settings.   Used to run tests and build the documentation.</li> </ul> </li> <li> <p><code>docs/</code> - Mkdocs documentation.</p> </li> <li><code>examples/</code> - Project's examples.</li> <li><code>src/</code> - Project's source code.</li> <li><code>tests/</code> - Project's Pytest test suite.</li> <li><code>.gitignore</code> - Gitignore file.</li> <li><code>Dockerfile</code> - Dockerfile for development container.</li> <li><code>mkdocs.yml</code> - Mkdocs configuration file.</li> <li><code>pyproject.toml</code> - pyproject.toml file for python tools configuration.</li> </ul>"},{"location":"dev/codequality/","title":"Code Quality Guide","text":"<p>We share the common code quality standards between all Gufo Labs projects.</p>"},{"location":"dev/codequality/#python-code-formatting","title":"Python Code Formatting","text":"<p>All Python code must be formatting using Black code formatter with settings defined in the project's <code>pyproject.toml</code> file.</p>"},{"location":"dev/codequality/#python-code-linting","title":"Python Code Linting","text":"<p>All Python code must pass ruff tests with the project's settings.</p>"},{"location":"dev/codequality/#python-code-static-checks","title":"Python Code Static Checks","text":"<p>All python code must pass Mypy type checks in the <code>strict</code> mode.</p>"},{"location":"dev/codequality/#test-suite-coverage","title":"Test Suite Coverage","text":"<p>The test suite must provide 100% code coverage whenever possible.</p>"},{"location":"dev/codequality/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Documentation must be clean and mean.</li> </ul>"},{"location":"dev/common/","title":"Developer's Common  Tasks","text":""},{"location":"dev/common/#bump-version","title":"Bump Version","text":"<ul> <li> Change <code>__version__</code> in <code>src/gufo/acme/__init__.py</code></li> <li> Add section in <code>CHANGELOG.md</code></li> </ul>"},{"location":"dev/environment/","title":"Developer's Environment","text":"<p>To participate in development you need to prepare the developer's environment first. Depending on the preferable tools, your mileage may vary.</p>"},{"location":"dev/environment/#visual-studio-code-dev-container","title":"Visual Studio Code Dev Container","text":"<p>The easiest way to start the development is to use Visual Studio Code with Remote Containers plugin. Just click on the green sign in the lower-left corner and select the \"Reopen in Container\" menu item. You'll get all the required formatting and linting settings out of the box.</p>"},{"location":"dev/standards/","title":"Supported Standards","text":"<p>Gufo ACME implements and is guided by the following standards:</p>"},{"location":"dev/standards/#rfc","title":"RFC","text":"<ul> <li>RFC-8555: Automatic Certificate Management Environment (ACME)</li> </ul>"},{"location":"dev/standards/#python-pep","title":"Python PEP","text":"<ul> <li>PEP8: Style Guide for Python Code</li> <li>PEP561: Distributing and Packaging Type Information</li> </ul>"},{"location":"dev/testing/","title":"Building and Testing","text":"<p>Before starting building and testing package set up  Developer's Environment first. From here and below we consider the shell's current directory matches the project's root directory.</p>"},{"location":"dev/testing/#building-package","title":"Building Package","text":"<p>To test the package build run:</p> <pre><code>$ python -m build --sdist --wheel\n</code></pre> <p>Compiled packages will be available in the <code>dist/</code> directory.</p>"},{"location":"dev/testing/#running-tests","title":"Running tests","text":"<p>To run the test suit:</p> <pre><code>$ pytest -vv\n</code></pre>"},{"location":"dev/testing/#running-lints","title":"Running Lints","text":"<p>All lints are checked as part of GitHub Actions Workflow. You may run lints manually before committing to the project.</p>"},{"location":"dev/testing/#check-formatting","title":"Check Formatting","text":"<p>Python Code Formatting is the mandatory requirement in our Code Quality standards. To check code formatting run:</p> <pre><code>$ black --check examples/ src/ tests/\n</code></pre> <p>To fix formatting errors run: <pre><code>$ black examples/ src/ tests/\n</code></pre></p> <p>We recommend setting python code formatting on file saving (Done in VS Code Dev Container out of the box).</p>"},{"location":"dev/testing/#python-code-lints","title":"Python Code Lints","text":"<p>Python Code Linting is the mandatory requirement in our Code Quality standards. To check code for linting errors run:</p> <pre><code>$ ruff examples/ src/ tests/\n</code></pre>"},{"location":"dev/testing/#python-code-static-checks","title":"Python Code Static Checks","text":"<p>Python Code Static Checks is the mandatory requirement in our Code Quality standards. To check code for typing errors run:</p> <pre><code>$ mypy --strict src/\n</code></pre>"},{"location":"dev/testing/#preparing-a-testing-environment","title":"Preparing a Testing Environment","text":"<p>The Gufo ACME test suite includes a real-world scenario for signing a certificate using the Letsencrypt staging environment.</p> <p>Gufo Labs provides all the necessary infrastructure to run tests in the CI environment. On local environments, the test is skipped by default.</p> <p>To enable the test in your local environment, additional infrastructure is needed.</p>"},{"location":"dev/testing/#davacmeclient","title":"DavAcmeClient","text":"<ol> <li>Have control over a DNS zone (later <code>&lt;mydomain&gt;</code>).</li> <li>Set up an Nginx server.</li> </ol> <p>Start by creating a testing <code>A</code> record (e.g., <code>acme-ci</code>), pointing to your Nginx server.</p> <pre><code>acme-ci IN A &lt;nginx ip&gt;\n</code></pre> <p>Next, prepare a configuration file and place it in your Nginx config directory (<code>/etc/nginx/conf.d/acme-ci</code>, depending on your distribution).</p> /etc/nginx/conf.d/acme-ci<pre><code>server {\n  listen 80;\n  server_name acme-ci.&lt;domain&gt;;\n  access_log  /var/log/nginx/acme-ci.&lt;domain&gt;.access.log timed_upstream;\n  error_log  /var/log/nginx/acme-ci.&lt;domain&gt;.error.log;\n\n  location /.well-known/acme-challenge/ {\n    alias /www/acme-ci/;\n    dav_methods PUT DELETE;\n    limit_except GET {\n    auth_basic \"Staging area\";\n    auth_basic_user_file \"/etc/nginx/auth/acme-ci\"; \n    }\n  }\n}\n</code></pre> <p>Then create a directory for tokens</p> <pre><code>mkdir /www/acme-ci\nchmod 700 /www/acme-ci\nchown nginx /www/acme-ci\n</code></pre> <p>After that, prepare a password for authorization:</p> <p>Create a separate directory:</p> <pre><code>mkdir /etc/nginx/auth\n</code></pre> <p>Generate a password: <pre><code>openssl rand 21 | base64\n</code></pre> And remember it.</p> <p>Then create a password file, replacing  and  with the desired username and the generated password. <pre><code>htpasswd -b /etc/nginx/auth/acme-ci &lt;user&gt; &lt;password&gt;\n</code></pre> <p>Finally, reload and Nginx:</p> <pre><code>service nginx reload\n</code></pre> <p>Check the setup:</p> <pre><code>curl -X PUT -d \"777\" --user \"&lt;user&gt;:&lt;password&gt;\" http://acme-ci.&lt;domain&gt;/.well-known/acme-challenge/777\n</code></pre> <p>The file /www/acme-ci/777 should appear.</p> <p>Your environment is now ready. Before running the test suite, execute the following commands in your development environment:</p> <pre><code>export CI_ACME_TEST_DOMAIN=acme-ci.&lt;domain&gt;\nexport CI_DAV_TEST_DOMAIN=acme-ci.&lt;domain&gt;\nexport CI_DAV_TEST_USER=&lt;user&gt;\nexport CI_DAV_TEST_PASSWORD=&lt;password&gt;\n</code></pre>"},{"location":"dev/testing/#powerdnsacmeclient","title":"PowerDnsAcmeClient","text":"<p>We're considering:</p> <ul> <li>We're perform testig on csr-proxy-test. <li>Your PowerDNS server's name is pdns. <p>First, in zone <code>&lt;domain&gt;</code> create a glue record pointing to your PowerDNS server:</p> <pre><code>csr-proxy-test IN IS pdns.&lt;domain&gt;\n</code></pre> <p>Create <code>csr-proxy-test.&lt;domain&gt;</code> zone:</p> <pre><code>pdnsutil create-zone csr-proxy-test.gufolabs.com\n</code></pre> <p>Your environment is now ready. Before running the test suite, execute the following commands in your development environment:</p> <pre><code>export CI_POWERDNS_TEST_DOMAIN=csr-proxy-test.&lt;domain&gt;\nexport CI_POWERDNS_TEST_API_URL=https://&lt;power-dns-url&gt;\nexport CI_POWERDNS_TEST_API_KEY=&lt;api key&gt;\n</code></pre>"},{"location":"dev/testing/#python-test-code-coverage-check","title":"Python Test Code Coverage Check","text":"<p>To evaluate code coverage run tests:</p> <pre><code>$ coverage run -m pytest -vv\n</code></pre> <p>To report the coverage after the test run:</p> <pre><code>$ coverage report\n</code></pre> <p>To show line-by-line coverage:</p> <pre><code>$ coverage html\n</code></pre> <p>Then open <code>dist/coverage/index.html</code> file in your browser.</p>"},{"location":"dev/testing/#building-documentation","title":"Building Documentation","text":"<p>To rebuild and check documentation run</p> <pre><code>$ mkdocs serve\n</code></pre> <p>We recommend using Grammarly service to check documentation for common errors.</p>"},{"location":"examples/","title":"Gufo ACME Examples","text":"<p>Dive into practical examples with detailed explanations to accelerate your learning of Gufo ACME.</p> <ul> <li>get_private_key: Generating RSA Private Key.</li> <li>get_csr: Generating a Certificate Signing Request.</li> <li>acme_register: Register ACME Account.</li> <li>acme_sign: Certificate Signing.</li> </ul>"},{"location":"examples/acme_register/","title":"Gufo ACME Examples: Register ACME Account","text":"<p>We have mastered how to create a Certificate Signing Request in our get_csr example. This guide will drive you through an ACME account registration process. An account registration process is crucial to perform all other operations, ACME is intended to: The certificate signing.</p> acme_register.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\nDIRECTORY = \"https://acme-staging-v02.api.letsencrypt.org/directory\"\n\n\nasync def main(email: str, client_state_path: str) -&gt; None:\n    client_key = AcmeClient.get_key()\n    async with AcmeClient(DIRECTORY, key=client_key) as client:\n        await client.new_account(email)\n        state = client.get_state()\n    with open(client_state_path, \"wb\") as fp:\n        fp.write(state)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1], sys.argv[2]))\n</code></pre> <p>The code is straightforward:</p> acme_register.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\nDIRECTORY = \"https://acme-staging-v02.api.letsencrypt.org/directory\"\n\n\nasync def main(email: str, client_state_path: str) -&gt; None:\n    client_key = AcmeClient.get_key()\n    async with AcmeClient(DIRECTORY, key=client_key) as client:\n        await client.new_account(email)\n        state = client.get_state()\n    with open(client_state_path, \"wb\") as fp:\n        fp.write(state)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1], sys.argv[2]))\n</code></pre> <p>AcmeClient is an asynchronous client, so we need <code>asyncio.run()</code> function to launch it.</p> acme_register.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\nDIRECTORY = \"https://acme-staging-v02.api.letsencrypt.org/directory\"\n\n\nasync def main(email: str, client_state_path: str) -&gt; None:\n    client_key = AcmeClient.get_key()\n    async with AcmeClient(DIRECTORY, key=client_key) as client:\n        await client.new_account(email)\n        state = client.get_state()\n    with open(client_state_path, \"wb\") as fp:\n        fp.write(state)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1], sys.argv[2]))\n</code></pre> <p>Import <code>sys</code> module to parse the CLI argument.</p> <p>Warning</p> <p>We use <code>sys.argv</code> only for demonstration purposes. Use <code>argsparse</code> or alternatives in real-world applications.</p> acme_register.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\nDIRECTORY = \"https://acme-staging-v02.api.letsencrypt.org/directory\"\n\n\nasync def main(email: str, client_state_path: str) -&gt; None:\n    client_key = AcmeClient.get_key()\n    async with AcmeClient(DIRECTORY, key=client_key) as client:\n        await client.new_account(email)\n        state = client.get_state()\n    with open(client_state_path, \"wb\") as fp:\n        fp.write(state)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1], sys.argv[2]))\n</code></pre> <p>Then we import an <code>AcmeClient</code> itself.</p> <p>acme_register.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\nDIRECTORY = \"https://acme-staging-v02.api.letsencrypt.org/directory\"\n\n\nasync def main(email: str, client_state_path: str) -&gt; None:\n    client_key = AcmeClient.get_key()\n    async with AcmeClient(DIRECTORY, key=client_key) as client:\n        await client.new_account(email)\n        state = client.get_state()\n    with open(client_state_path, \"wb\") as fp:\n        fp.write(state)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1], sys.argv[2]))\n</code></pre> The crucial ACME protocol concept is the Directory. The directory is an URL which allows to fetch all necessary information about ACME server. In our case we're using Letsencrypt staging directory.</p> <p>Warning</p> <p>The staging server should be used only for testing purposes. Replace the <code>DIRECTORY</code> variable with the productive endpoint to get the real certificates.</p> <p>acme_register.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\nDIRECTORY = \"https://acme-staging-v02.api.letsencrypt.org/directory\"\n\n\nasync def main(email: str, client_state_path: str) -&gt; None:\n    client_key = AcmeClient.get_key()\n    async with AcmeClient(DIRECTORY, key=client_key) as client:\n        await client.new_account(email)\n        state = client.get_state()\n    with open(client_state_path, \"wb\") as fp:\n        fp.write(state)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1], sys.argv[2]))\n</code></pre> We define the <code>main</code> function to wrap our code. It assepts the following parameters:</p> <ul> <li><code>email</code> - an account email.</li> <li><code>client_state</code> - a path to where we can save the state     of the client to reuse it later.</li> </ul> <p>Note</p> <p>The main function is asynchronous</p> <p>acme_register.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\nDIRECTORY = \"https://acme-staging-v02.api.letsencrypt.org/directory\"\n\n\nasync def main(email: str, client_state_path: str) -&gt; None:\n    client_key = AcmeClient.get_key()\n    async with AcmeClient(DIRECTORY, key=client_key) as client:\n        await client.new_account(email)\n        state = client.get_state()\n    with open(client_state_path, \"wb\") as fp:\n        fp.write(state)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1], sys.argv[2]))\n</code></pre> The client uses secret key to sign all communications to the server. Later, this key will be bound to account. We use <code>AcmeClient.get_key()</code> function to generate a new key.</p> <p>acme_register.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\nDIRECTORY = \"https://acme-staging-v02.api.letsencrypt.org/directory\"\n\n\nasync def main(email: str, client_state_path: str) -&gt; None:\n    client_key = AcmeClient.get_key()\n    async with AcmeClient(DIRECTORY, key=client_key) as client:\n        await client.new_account(email)\n        state = client.get_state()\n    with open(client_state_path, \"wb\") as fp:\n        fp.write(state)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1], sys.argv[2]))\n</code></pre> <code>AcmeClient</code> requires two mandatory parameters:</p> <ul> <li>ACME Directory URL.</li> <li>The client key.</li> </ul> <p>We use <code>async with</code> construct to initialize the client and make it available within the block.</p> acme_register.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\nDIRECTORY = \"https://acme-staging-v02.api.letsencrypt.org/directory\"\n\n\nasync def main(email: str, client_state_path: str) -&gt; None:\n    client_key = AcmeClient.get_key()\n    async with AcmeClient(DIRECTORY, key=client_key) as client:\n        await client.new_account(email)\n        state = client.get_state()\n    with open(client_state_path, \"wb\") as fp:\n        fp.write(state)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1], sys.argv[2]))\n</code></pre> <p>We use <code>new_account()</code> call to register the new account. Since then the client is considered bound and we can use it for other operations.</p> <p>acme_register.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\nDIRECTORY = \"https://acme-staging-v02.api.letsencrypt.org/directory\"\n\n\nasync def main(email: str, client_state_path: str) -&gt; None:\n    client_key = AcmeClient.get_key()\n    async with AcmeClient(DIRECTORY, key=client_key) as client:\n        await client.new_account(email)\n        state = client.get_state()\n    with open(client_state_path, \"wb\") as fp:\n        fp.write(state)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1], sys.argv[2]))\n</code></pre> Client key and account information is required for any account manipulations. So we save them for later usage.</p> <p>acme_register.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\nDIRECTORY = \"https://acme-staging-v02.api.letsencrypt.org/directory\"\n\n\nasync def main(email: str, client_state_path: str) -&gt; None:\n    client_key = AcmeClient.get_key()\n    async with AcmeClient(DIRECTORY, key=client_key) as client:\n        await client.new_account(email)\n        state = client.get_state()\n    with open(client_state_path, \"wb\") as fp:\n        fp.write(state)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1], sys.argv[2]))\n</code></pre> Open file for write, note the state has <code>bytes</code> type, so we need to use <code>wb</code> option to write a binary file. Then write our state.</p> <p>acme_register.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\nDIRECTORY = \"https://acme-staging-v02.api.letsencrypt.org/directory\"\n\n\nasync def main(email: str, client_state_path: str) -&gt; None:\n    client_key = AcmeClient.get_key()\n    async with AcmeClient(DIRECTORY, key=client_key) as client:\n        await client.new_account(email)\n        state = client.get_state()\n    with open(client_state_path, \"wb\") as fp:\n        fp.write(state)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1], sys.argv[2]))\n</code></pre> If we're called from command line, get a command line arguments:</p> <ol> <li>Account email</li> <li>State path</li> </ol>"},{"location":"examples/acme_register/#running","title":"Running","text":"<p>Run the example:</p> <pre><code>python3 examples/acme_register.py mymail@mydomain.com /tmp/acme.json\n</code></pre> <p>Check the <code>/tmp/acme.json</code> file:</p> /tmp/acme.json<pre><code>{\n  \"directory\": \"https://acme-staging-v02.api.letsencrypt.org/directory\",\n  \"key\": {\n    \"n\": \"qhd84f-9Wb...5AQQ\",\n    \"e\": \"AQAB\",\n    \"d\": \"Sgan5MoDNC..Fk9cw\",\n    \"p\": \"6BPvgdy6_i..gkdM\",\n    \"q\": \"u5_dOHJqNh..bRRs\",\n    \"dp\": \"C9PYRPoG3..MVf9k\",\n    \"dq\": \"LQ5U14tSS..iRIGU\",\n    \"qi\": \"5AcvleFCl..jBFsQ\"\n  },\n  \"account_url\": \"https://acme-staging-v02.api.letsencrypt.org/acme/acct/1234567\"\n}\n</code></pre>"},{"location":"examples/acme_register/#conclusions","title":"Conclusions","text":"<p>In this section we have mastered the process of the account registration. Now we're ready to a major ACME's step: A sertificate signing.</p>"},{"location":"examples/acme_sign/","title":"Gufo ACME Examples: Signing Certificate","text":"<p>We have mastered how to create an ACME server account in our acme_register example. Now it is time to bring all pieces together and get a signed certificate for our domain.</p> <p>The ACME protocol requires that the client will prove the ownership of the domain by one of available means, called challenge. In out example we will use <code>http-01</code> type of challenge which requires the client will obtain a token from ACME server and made it available via well-known URL like <code>http://&lt;domain&gt;/.well-known/acme-challenges/&lt;token&gt;</code>.</p> <p>We consider you have a Nginx server set up and running with config like this:</p> /etc/nginx/conf.d/<pre><code>server {\n  listen 80;\n  server_name &lt;domain&gt;;\n\n  location /.well-known/acme-challenge/ {\n    alias /www/acme/;\n  }\n}\n</code></pre> <p>So our task is:</p> <ol> <li>Get a token for domain.</li> <li>Place file into <code>/www/acme/</code> directory.</li> <li>Ask the server to perform validation.</li> <li>Grab the certificate.</li> </ol> <p>The ACME protocol is quite complex and really require much more stages, but, luckily, Gufo ACME hides all the complexity and provides clean API.</p> <p>acme_sign.py<pre><code>import asyncio\nimport os\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\nfrom gufo.acme.types import AcmeChallenge\n\nCHALLENGE_DIR = \"/www/acme/\"\n\n\nclass SignAcmeClient(AcmeClient):\n    async def fulfill_http_01(\n        self, domain: str, challenge: AcmeChallenge\n    ) -&gt; bool:\n        v = self.get_key_authorization(challenge)\n        with open(os.path.join(CHALLENGE_DIR, challenge.token), \"wb\") as fp:\n            fp.write(v)\n        return True\n\n    async def clear_http_01(\n        self: AcmeClient, domain: str, challenge: AcmeChallenge\n    ) -&gt; None:\n        os.unlink(os.path.join(CHALLENGE_DIR, challenge.token))\n\n\nasync def main(\n    client_state_path: str, domain: str, csr_path: str, cert_path: str\n) -&gt; None:\n    with open(client_state_path, \"wb\") as fp:\n        state = fp.read()\n    with open(csr_path, \"wb\") as fp:\n        csr = fp.read()\n    async with SignAcmeClient.from_state(state) as client:\n        cert = await client.sign(domain, csr)\n    with open(cert_path, \"wb\") as fp:\n        fp.write(cert)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4]))\n</code></pre> The code is straightforward:</p> acme_sign.py<pre><code>import asyncio\nimport os\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\nfrom gufo.acme.types import AcmeChallenge\n</code></pre> <p>AcmeClient is an asynchronous client, so we need <code>asyncio.run()</code> function to launch it.</p> acme_sign.py<pre><code>import asyncio\nimport os\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\nfrom gufo.acme.types import AcmeChallenge\n</code></pre> <p>Import <code>os</code> module which is required to join paths.</p> acme_sign.py<pre><code>import asyncio\nimport os\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\nfrom gufo.acme.types import AcmeChallenge\n</code></pre> <p>Import <code>sys</code> module to parse the CLI argument.</p> <p>Warning</p> <p>We use <code>sys.argv</code> only for demonstration purposes. Use <code>argsparse</code> or alternatives in real-world applications.</p> acme_sign.py<pre><code>import asyncio\nimport os\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\nfrom gufo.acme.types import AcmeChallenge\n</code></pre> <p>Then we import an <code>AcmeClient</code> itself.</p> <p>acme_sign.py<pre><code>import asyncio\nimport os\nimport sys\n\nfrom gufo.acme.clients.base import AcmeClient\nfrom gufo.acme.types import AcmeChallenge\n</code></pre> We also need an <code>AcmeChallenge</code> type.</p> <p>acme_sign.py<pre><code>from gufo.acme.types import AcmeChallenge\n\nCHALLENGE_DIR = \"/www/acme/\"\n\n\nclass SignAcmeClient(AcmeClient):\n</code></pre> The crucial ACME protocol concept is the Directory. The directory is an URL which allows to fetch all necessary information about ACME server. In our case we're using Letsencrypt staging directory.</p> <p>Warning</p> <p>The staging server should be used only for testing purposes. Replace the <code>DIRECTORY</code> variable with the productive endpoint to get the real certificates.</p> <p>acme_sign.py<pre><code>class SignAcmeClient(AcmeClient):\n    async def fulfill_http_01(\n        self, domain: str, challenge: AcmeChallenge\n    ) -&gt; bool:\n        v = self.get_key_authorization(challenge)\n        with open(os.path.join(CHALLENGE_DIR, challenge.token), \"wb\") as fp:\n            fp.write(v)\n        return True\n\n    async def clear_http_01(\n        self: AcmeClient, domain: str, challenge: AcmeChallenge\n    ) -&gt; None:\n        os.unlink(os.path.join(CHALLENGE_DIR, challenge.token))\n</code></pre> We need to provide the implementation of the challenge fulfillment. The Gufo ACME's API provides special methods which can be overriden in subclasses to implement the desired behavior. So we are creating a subclass of <code>AcmeClient</code>.</p> <p>acme_sign.py<pre><code>class SignAcmeClient(AcmeClient):\n    async def fulfill_http_01(\n        self, domain: str, challenge: AcmeChallenge\n    ) -&gt; bool:\n        v = self.get_key_authorization(challenge)\n        with open(os.path.join(CHALLENGE_DIR, challenge.token), \"wb\") as fp:\n            fp.write(v)\n        return True\n\n    async def clear_http_01(\n        self: AcmeClient, domain: str, challenge: AcmeChallenge\n    ) -&gt; None:\n        os.unlink(os.path.join(CHALLENGE_DIR, challenge.token))\n</code></pre> We're implementing <code>http-01</code> challenge, so we need to override <code>fulfill_http_01</code> method. This is an asyncronous method so we use any async function inside. It accepts two parameters:</p> <ul> <li><code>domain</code> - a domain name.</li> <li><code>challenge</code> - a AcmeChallenge structure, which has     a <code>token</code> field, containing challenge token.</li> </ul> <p>Function returns <code>True</code> when fulfillment has beed processed correctly, or <code>False</code>, if we wan't provide a fulfillment.</p> <p>acme_sign.py<pre><code>class SignAcmeClient(AcmeClient):\n    async def fulfill_http_01(\n        self, domain: str, challenge: AcmeChallenge\n    ) -&gt; bool:\n        v = self.get_key_authorization(challenge)\n        with open(os.path.join(CHALLENGE_DIR, challenge.token), \"wb\") as fp:\n            fp.write(v)\n        return True\n\n    async def clear_http_01(\n        self: AcmeClient, domain: str, challenge: AcmeChallenge\n    ) -&gt; None:\n        os.unlink(os.path.join(CHALLENGE_DIR, challenge.token))\n</code></pre> According the ACME protocol, we need to place a specially formed data to prove our authority. The data contain challenge token and the fingerprint of the client's key. The calculation may be tricky, but Gufo ACME provides a <code>AcmeClient.get_key_authorization()</code> method, which performs all necessary calculations. So we pass <code>challenge</code> parameter and grab an authorization data as value of the variable <code>v</code>.</p> <p>acme_sign.py<pre><code>class SignAcmeClient(AcmeClient):\n    async def fulfill_http_01(\n        self, domain: str, challenge: AcmeChallenge\n    ) -&gt; bool:\n        v = self.get_key_authorization(challenge)\n        with open(os.path.join(CHALLENGE_DIR, challenge.token), \"wb\") as fp:\n            fp.write(v)\n        return True\n\n    async def clear_http_01(\n        self: AcmeClient, domain: str, challenge: AcmeChallenge\n    ) -&gt; None:\n        os.unlink(os.path.join(CHALLENGE_DIR, challenge.token))\n</code></pre> We're building real file name by adding token's value to <code>CHALLENGE_DIR</code>. The autrorization key has type <code>bytes</code> so we open the file in <code>wb</code> mode.</p> <p>acme_sign.py<pre><code>class SignAcmeClient(AcmeClient):\n    async def fulfill_http_01(\n        self, domain: str, challenge: AcmeChallenge\n    ) -&gt; bool:\n        v = self.get_key_authorization(challenge)\n        with open(os.path.join(CHALLENGE_DIR, challenge.token), \"wb\") as fp:\n            fp.write(v)\n        return True\n\n    async def clear_http_01(\n        self: AcmeClient, domain: str, challenge: AcmeChallenge\n    ) -&gt; None:\n        os.unlink(os.path.join(CHALLENGE_DIR, challenge.token))\n</code></pre> Finally, we return <code>True</code> to sigalize, we have performed fulfillment and ready to start validation.</p> <p>acme_sign.py<pre><code>class SignAcmeClient(AcmeClient):\n    async def fulfill_http_01(\n        self, domain: str, challenge: AcmeChallenge\n    ) -&gt; bool:\n        v = self.get_key_authorization(challenge)\n        with open(os.path.join(CHALLENGE_DIR, challenge.token), \"wb\") as fp:\n            fp.write(v)\n        return True\n\n    async def clear_http_01(\n        self: AcmeClient, domain: str, challenge: AcmeChallenge\n    ) -&gt; None:\n        os.unlink(os.path.join(CHALLENGE_DIR, challenge.token))\n</code></pre> The ACME protocol definition exlicitly notes that client may clean up prepared data after the validation. <code>AcmeClient</code> allows to add own cleanup code by overriding <code>cleanup_*</code> methods. In our case we're overriding <code>clear_http_01</code> method. Just like <code>fulfill_http_01</code>, it accepts two parameters:</p> <ul> <li><code>domain</code> - a domain name.</li> <li><code>challenge</code> - a AcmeChallenge structure, which has     a <code>token</code> field, containing challenge token.</li> </ul> <p>acme_sign.py<pre><code>class SignAcmeClient(AcmeClient):\n    async def fulfill_http_01(\n        self, domain: str, challenge: AcmeChallenge\n    ) -&gt; bool:\n        v = self.get_key_authorization(challenge)\n        with open(os.path.join(CHALLENGE_DIR, challenge.token), \"wb\") as fp:\n            fp.write(v)\n        return True\n\n    async def clear_http_01(\n        self: AcmeClient, domain: str, challenge: AcmeChallenge\n    ) -&gt; None:\n        os.unlink(os.path.join(CHALLENGE_DIR, challenge.token))\n</code></pre> We're removing the file created in the <code>fulfill_http_01</code> method.</p> <p>acme_sign.py<pre><code>async def main(\n    client_state_path: str, domain: str, csr_path: str, cert_path: str\n) -&gt; None:\n    with open(client_state_path, \"wb\") as fp:\n        state = fp.read()\n    with open(csr_path, \"wb\") as fp:\n        csr = fp.read()\n    async with SignAcmeClient.from_state(state) as client:\n        cert = await client.sign(domain, csr)\n    with open(cert_path, \"wb\") as fp:\n        fp.write(cert)\n</code></pre> We define the <code>main</code> function to wrap our code. It assepts the following parameters:</p> <ul> <li><code>client_state_path</code> - a path to a client's state we have created     in our acme_register example.</li> <li><code>domain_name</code> - our domain name.</li> <li><code>csr_path</code> - a path to the CSR we have created in our     get_csr example.</li> <li><code>cert_path</code> - a path to where we must write a resulting certificate.</li> </ul> <p>Note</p> <p>The main function is asynchronous</p> <p>acme_sign.py<pre><code>async def main(\n    client_state_path: str, domain: str, csr_path: str, cert_path: str\n) -&gt; None:\n    with open(client_state_path, \"wb\") as fp:\n        state = fp.read()\n    with open(csr_path, \"wb\") as fp:\n        csr = fp.read()\n    async with SignAcmeClient.from_state(state) as client:\n        cert = await client.sign(domain, csr)\n    with open(cert_path, \"wb\") as fp:\n        fp.write(cert)\n</code></pre> We're reading client state from <code>client_state_path</code>. The state is binary so we're opening the file in <code>rb</code> mode.</p> <p>acme_sign.py<pre><code>async def main(\n    client_state_path: str, domain: str, csr_path: str, cert_path: str\n) -&gt; None:\n    with open(client_state_path, \"wb\") as fp:\n        state = fp.read()\n    with open(csr_path, \"wb\") as fp:\n        csr = fp.read()\n    async with SignAcmeClient.from_state(state) as client:\n        cert = await client.sign(domain, csr)\n    with open(cert_path, \"wb\") as fp:\n        fp.write(cert)\n</code></pre> We're reading CSR from <code>csr_path</code>. The state is binary so we're opening the file in <code>rb</code> mode.</p> <p>acme_sign.py<pre><code>async def main(\n    client_state_path: str, domain: str, csr_path: str, cert_path: str\n) -&gt; None:\n    with open(client_state_path, \"wb\") as fp:\n        state = fp.read()\n    with open(csr_path, \"wb\") as fp:\n        csr = fp.read()\n    async with SignAcmeClient.from_state(state) as client:\n        cert = await client.sign(domain, csr)\n    with open(cert_path, \"wb\") as fp:\n        fp.write(cert)\n</code></pre> We're instantiating <code>AcmeClient</code> directly from state by using <code>from_state()</code> method. Note, we're restoring state not into the <code>AcmeClient</code>, but in our <code>SignAcmeClient</code> subclass. The new <code>client</code> instance loads the private key, directory, and account information directly from state.</p> <p>acme_sign.py<pre><code>async def main(\n    client_state_path: str, domain: str, csr_path: str, cert_path: str\n) -&gt; None:\n    with open(client_state_path, \"wb\") as fp:\n        state = fp.read()\n    with open(csr_path, \"wb\") as fp:\n        csr = fp.read()\n    async with SignAcmeClient.from_state(state) as client:\n        cert = await client.sign(domain, csr)\n    with open(cert_path, \"wb\") as fp:\n        fp.write(cert)\n</code></pre> And finally, we call an <code>AcmeClient.sign</code> method, which accepts domain name and CSR. The <code>sign</code> method simple hides all the protocol's complexity and simply returns us a signed certificate in PEM format.</p> <p>acme_sign.py<pre><code>async def main(\n    client_state_path: str, domain: str, csr_path: str, cert_path: str\n) -&gt; None:\n    with open(client_state_path, \"wb\") as fp:\n        state = fp.read()\n    with open(csr_path, \"wb\") as fp:\n        csr = fp.read()\n    async with SignAcmeClient.from_state(state) as client:\n        cert = await client.sign(domain, csr)\n    with open(cert_path, \"wb\") as fp:\n        fp.write(cert)\n</code></pre> We're writing a result into the output file. The certificate has type bytes and we're opening the file in <code>wb</code> mode.</p> <p>acme_sign.py<pre><code>if __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4]))\n</code></pre> If we're called from command line, get a command line arguments:</p> <ol> <li>Client's state path</li> <li>Domain name</li> <li>CSR path</li> <li>Certificate path</li> </ol>"},{"location":"examples/acme_sign/#running","title":"Running","text":"<p>Run the example:</p> <pre><code>python3 examples/acme_sign.py /tmp/acme.json mydomain.com /tmp/csr.pem /tmp/cert.pem\n</code></pre> <p>Check the <code>/tmp/cert.pem</code> file:</p> /tmp/cert.pem<pre><code>-----BEGIN CERTIFICATE-----\nMIIFZTCCA00CFGMFCNLNSJLkcnJn4XJUGhtHh5JXMA0GCSqGSIb3DQEBCwUAMG8x\nCzAJBgNVBAYTAklUMQ8wDQYDVQQIDAZNaWxhbm8xDzANBgNVBAcMBk1pbGFubzES\n...\n+pqFSNi9tsBy/T9zdVa4giUW68Zc3ezN+t+bvD/qNvAsH+c2ajR8utK0ehv+FpGH\nnOfZOASlIEp2te2A6bhHqUqh7LIydzg4YV7FSnfoabO2wDbnHGESZ63/FkyYJHxH\nSgFIpXon3mbTvYkSMk+ToN9Fr0n795G37W2pylEfXI28IJ4KpajiheA=\n-----END CERTIFICATE-----\n</code></pre>"},{"location":"examples/acme_sign/#conclusions","title":"Conclusions","text":"<p>In this section we have finally tied all pieces together and wrote a simple certificate signing bot. Refer to the Reference for further details.</p>"},{"location":"examples/get_csr/","title":"Gufo ACME Examples: Generating Certificate Signing Request","text":"<p>We have mastered how to generate a private key in our get_private_key example. This guide will drive you through the next step: the generation of the Certificate Signing Request (CSR). The CSR is the entity which passed to the Certificate Authority (CA) to obtain a signed certificate for domain.</p> get_csr.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(domain: str, private_key_path: str, csr_path: str) -&gt; None:\n    with open(private_key_path, \"rb\") as fp:\n        pk = fp.read()\n    csr = AcmeClient.get_domain_csr(domain, pk)\n    with open(csr_path, \"wb\") as fp:\n        fp.write(csr)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1], sys.argv[2], sys.argv[3])\n</code></pre> <p>The code is straightforward:</p> get_csr.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(domain: str, private_key_path: str, csr_path: str) -&gt; None:\n    with open(private_key_path, \"rb\") as fp:\n        pk = fp.read()\n    csr = AcmeClient.get_domain_csr(domain, pk)\n    with open(csr_path, \"wb\") as fp:\n        fp.write(csr)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1], sys.argv[2], sys.argv[3])\n</code></pre> <p>Import <code>sys</code> module to parse the CLI argument.</p> <p>Warning</p> <p>We use <code>sys.argv</code> only for demonstration purposes. Use <code>argsparse</code> or alternatives in real-world applications.</p> get_csr.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(domain: str, private_key_path: str, csr_path: str) -&gt; None:\n    with open(private_key_path, \"rb\") as fp:\n        pk = fp.read()\n    csr = AcmeClient.get_domain_csr(domain, pk)\n    with open(csr_path, \"wb\") as fp:\n        fp.write(csr)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1], sys.argv[2], sys.argv[3])\n</code></pre> <p>Then we import an <code>AcmeClient</code> itself.</p> <p>get_csr.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(domain: str, private_key_path: str, csr_path: str) -&gt; None:\n    with open(private_key_path, \"rb\") as fp:\n        pk = fp.read()\n    csr = AcmeClient.get_domain_csr(domain, pk)\n    with open(csr_path, \"wb\") as fp:\n        fp.write(csr)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1], sys.argv[2], sys.argv[3])\n</code></pre> We define the <code>main</code> function to wrap our code. It assepts the following parameters:</p> <ul> <li><code>domain</code> - a domain name.</li> <li><code>private_key_path</code> - a path to private key in PEM format,     which we have generated in out get_private_key     example.</li> <li><code>csr_path</code> - a path to store resulting CSR.</li> </ul> <p>get_csr.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(domain: str, private_key_path: str, csr_path: str) -&gt; None:\n    with open(private_key_path, \"rb\") as fp:\n        pk = fp.read()\n    csr = AcmeClient.get_domain_csr(domain, pk)\n    with open(csr_path, \"wb\") as fp:\n        fp.write(csr)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1], sys.argv[2], sys.argv[3])\n</code></pre> First we need to load our private key. Note we need a <code>bytes</code> type, so we open file with <code>rb</code> option. The <code>pk</code> variable contains our private key.</p> <p>get_csr.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(domain: str, private_key_path: str, csr_path: str) -&gt; None:\n    with open(private_key_path, \"rb\") as fp:\n        pk = fp.read()\n    csr = AcmeClient.get_domain_csr(domain, pk)\n    with open(csr_path, \"wb\") as fp:\n        fp.write(csr)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1], sys.argv[2], sys.argv[3])\n</code></pre> <code>AcmeClient.get_domain_csr()</code> function generates a CSR in PEM format. It aceepts requred parameters:</p> <ul> <li><code>domain</code> - domain name</li> <li><code>private_key</code> - private key in PEM format.</li> </ul> <p>The <code>csr</code> variable cotains out CSR content.</p> <p>get_csr.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(domain: str, private_key_path: str, csr_path: str) -&gt; None:\n    with open(private_key_path, \"rb\") as fp:\n        pk = fp.read()\n    csr = AcmeClient.get_domain_csr(domain, pk)\n    with open(csr_path, \"wb\") as fp:\n        fp.write(csr)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1], sys.argv[2], sys.argv[3])\n</code></pre> Open file for write, note the CSR has <code>bytes</code> type, so we need to use <code>wb</code> option to write a binary file. Then write our CSR.</p> <p>get_csr.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(domain: str, private_key_path: str, csr_path: str) -&gt; None:\n    with open(private_key_path, \"rb\") as fp:\n        pk = fp.read()\n    csr = AcmeClient.get_domain_csr(domain, pk)\n    with open(csr_path, \"wb\") as fp:\n        fp.write(csr)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1], sys.argv[2], sys.argv[3])\n</code></pre> If we're called from command line, get a command line arguments:</p> <ol> <li>domain name</li> <li>private key path</li> <li>CSR path</li> </ol>"},{"location":"examples/get_csr/#running","title":"Running","text":"<p>Run the example:</p> <pre><code>python3 examples/get_csr.py example.com /tmp/key.pem /tmp/csr.pem\n</code></pre> <p>Check the <code>/tmp/csr.pem</code> file:</p> /tmp/csr.pem<pre><code>-----BEGIN CERTIFICATE REQUEST-----\nMIIEejCCAmICAQAwFjEUMBIGA1UEAwwLZXhhbXBsZS5jb20wggIiMA0GCSqGSIb3\nDQEBAQUAA4ICDwAwggIKAoICAQDbrR5OoTaM6EgxbRv0BCfTwpsYxskkY8p8CHEF\n...\nQBsW0aHYdWwW+UJ5ApzSJh9hT87C7madmOJ9LqozPf9tDDuaYv4/Ips9EKEv9pcN\nrKniaHZSBUGfBBqLq2a25E0cn19wly5FARPR1lIaEmz2sTV09AdM3kyEFM4bug==\n-----END CERTIFICATE REQUEST-----\n</code></pre>"},{"location":"examples/get_csr/#conclusions","title":"Conclusions","text":"<p>In this section we have mastered the process of the generation of the Certificate Signing Request. The resulting CSR may be passed to any Certificate Authority. In our next example we will write a simple ACME Bot to automate the certificate siging process.</p>"},{"location":"examples/get_private_key/","title":"Gufo ACME Examples: Generating RSA Private Key","text":"<p>This guide will drive you through the process of the generation of private key using Gufo ACME library. Generation of the private key is a first step for obtaining a signed certificate for your domain.</p> get_private_key.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(path: str) -&gt; None:\n    pk = AcmeClient.get_domain_private_key()\n    with open(path, \"wb\") as fp:\n        fp.write(pk)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1])\n</code></pre> <p>The code is straightforward:</p> get_private_key.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(path: str) -&gt; None:\n    pk = AcmeClient.get_domain_private_key()\n    with open(path, \"wb\") as fp:\n        fp.write(pk)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1])\n</code></pre> <p>Import <code>sys</code> module to parse the CLI argument.</p> <p>Warning</p> <p>We use <code>sys.argv</code> only for demonstration purposes. Use <code>argsparse</code> or alternatives in real-world applications.</p> get_private_key.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(path: str) -&gt; None:\n    pk = AcmeClient.get_domain_private_key()\n    with open(path, \"wb\") as fp:\n        fp.write(pk)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1])\n</code></pre> <p>Then we import an <code>AcmeClient</code> itself.</p> <p>get_private_key.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(path: str) -&gt; None:\n    pk = AcmeClient.get_domain_private_key()\n    with open(path, \"wb\") as fp:\n        fp.write(pk)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1])\n</code></pre> We define the <code>main</code> function to wrap our code. It assepts a <code>path</code> parameter, containing a path to the file to store a private key.</p> <p>get_private_key.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(path: str) -&gt; None:\n    pk = AcmeClient.get_domain_private_key()\n    with open(path, \"wb\") as fp:\n        fp.write(pk)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1])\n</code></pre> <code>AcmeClient.get_domain_private_key()</code> function generates a private key in PEM format. It assepts an optional parameter which defines a RSA key length. The default is 4096, which is suitable for our applications. This function is the static method, so we don't need to instantiate an <code>AcmeClient</code>.</p> <p>get_private_key.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(path: str) -&gt; None:\n    pk = AcmeClient.get_domain_private_key()\n    with open(path, \"wb\") as fp:\n        fp.write(pk)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1])\n</code></pre> Open file for write, note the key has <code>bytes</code> type, so we need to use <code>wb</code> option to write a binary file. The write our private key.</p> <p>get_private_key.py<pre><code>import sys\n\nfrom gufo.acme.clients.base import AcmeClient\n\n\ndef main(path: str) -&gt; None:\n    pk = AcmeClient.get_domain_private_key()\n    with open(path, \"wb\") as fp:\n        fp.write(pk)\n\n\nif __name__ == \"__main__\":\n    main(sys.argv[1])\n</code></pre> If we're called from command line, get a first command argument as a path and call our <code>main</code> function.</p>"},{"location":"examples/get_private_key/#running","title":"Running","text":"<p>Run the example:</p> <pre><code>python3 examples/get_private_key.py /tmp/key.pem\n</code></pre> <p>Check the <code>/tmp/key.pem</code> file:</p> /tmp/key.pem<pre><code>-----BEGIN RSA PRIVATE KEY-----\nMIIJKgIBAAKCAgEA260eTqE2jOhIMW0b9AQn08KbGMbJJGPKfAhxBfa0MIQ7g8Tb\n50tWbnK+NTdEAHZCfvfwpieVDgrwVNlPW5sL14xPltJ3zcQRydJTOFpV/WImtd6j\n...\nxgJwpjMz0pm+9Exoe8VwmUc/gOSatoOC9DRg+hAIG7FciNUVfEeXq8ImmcDypeSe\nwjBT33F36F0O22Ij4EVyW+etjp5hbboaKjjoxq/EkMTwwnET6HzpkMOj7+x/VQ==\n-----END RSA PRIVATE KEY-----\n</code></pre>"},{"location":"examples/get_private_key/#conclusions","title":"Conclusions","text":"<p>In this section we have mastered the process of the generation of the RSA public key using helper function. Let's proceed to next example and generate a Certificate Signed Request.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>gufo.acme<ul> <li>acme</li> <li>clients<ul> <li>base</li> <li>dav</li> <li>powerdns</li> <li>web</li> </ul> </li> <li>error</li> <li>log</li> <li>types</li> </ul> </li> </ul>"},{"location":"reference/gufo/acme/","title":"gufo.acme","text":"<p>An Python asyncio ACME client.</p> <p>Attributes:</p> Name Type Description <code>__version__</code> <p>Gufo ACME version.</p> <p>The package consists of the following modules:</p> <ul> <li>acme - ACME protocol messages.</li> <li>clients - Various ACME clients imlementations.</li> <li>error - Error classes.</li> <li>log - Logging utilities.</li> <li>types - Package public types.</li> </ul>"},{"location":"reference/gufo/acme/acme/","title":"gufo.acme.acme","text":"<p>ACME protocol JWS structures.</p>"},{"location":"reference/gufo/acme/acme/#gufo.acme.acme.AcmeHeader","title":"<code>AcmeHeader</code>","text":"<p>               Bases: <code>Header</code></p> <p>Structure for ACME JWS header.</p> <p>Attributes:</p> Name Type Description <code>nonce</code> <code>Optional[bytes]</code> <p>Request nonce.</p> <code>kid</code> <code>Optional[str]</code> <p>Account URL.</p> <code>url</code> <code>Optional[str]</code> <p>Request URL.</p>"},{"location":"reference/gufo/acme/acme/#gufo.acme.acme.AcmeJWS","title":"<code>AcmeJWS</code>","text":"<p>               Bases: <code>JWS</code></p> <p>Signed JWS for ACME protocol.</p>"},{"location":"reference/gufo/acme/acme/#gufo.acme.acme.AcmeJWS.sign","title":"<code>sign(payload, *, key, alg, nonce=None, url=None, kid=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Sign a payload and return signed JWS.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>bytes</code> <p>Request payload.</p> required <code>key</code> <code>JWK</code> <p>Account key.</p> required <code>alg</code> <code>JWASignature</code> <p>Signature algorithm.</p> required <code>nonce</code> <code>Optional[bytes]</code> <p>Request nonce.</p> <code>None</code> <code>url</code> <code>Optional[str]</code> <p>Request URL.</p> <code>None</code> <code>kid</code> <code>Optional[str]</code> <p>Account URL, if bound.</p> <code>None</code> <code>kwargs</code> <code>Dict[str, Any]</code> <p>Other arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>JWS</code> <p>Signed JWS.</p>"},{"location":"reference/gufo/acme/acme/#gufo.acme.acme.AcmeSignature","title":"<code>AcmeSignature</code>","text":"<p>               Bases: <code>Signature</code></p> <p>Signature for ACME JWS.</p>"},{"location":"reference/gufo/acme/error/","title":"gufo.acme.error","text":"<p>AcmeClient error classes.</p>"},{"location":"reference/gufo/acme/error/#gufo.acme.error.AcmeAlreadyRegistered","title":"<code>AcmeAlreadyRegistered</code>","text":"<p>               Bases: <code>AcmeError</code></p> <p>Client is alredy registered.</p>"},{"location":"reference/gufo/acme/error/#gufo.acme.error.AcmeAuthorizationError","title":"<code>AcmeAuthorizationError</code>","text":"<p>               Bases: <code>AcmeError</code></p> <p>Failed to pass an authorization.</p>"},{"location":"reference/gufo/acme/error/#gufo.acme.error.AcmeBadNonceError","title":"<code>AcmeBadNonceError</code>","text":"<p>               Bases: <code>AcmeError</code></p> <p>Server rejects a nounce as invalid.</p>"},{"location":"reference/gufo/acme/error/#gufo.acme.error.AcmeCertificateError","title":"<code>AcmeCertificateError</code>","text":"<p>               Bases: <code>AcmeError</code></p> <p>Failed to finalize.</p>"},{"location":"reference/gufo/acme/error/#gufo.acme.error.AcmeConnectError","title":"<code>AcmeConnectError</code>","text":"<p>               Bases: <code>AcmeError</code></p> <p>Failed to connect ACME server.</p>"},{"location":"reference/gufo/acme/error/#gufo.acme.error.AcmeError","title":"<code>AcmeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all Gufo Acme errors.</p>"},{"location":"reference/gufo/acme/error/#gufo.acme.error.AcmeExternalAccountRequred","title":"<code>AcmeExternalAccountRequred</code>","text":"<p>               Bases: <code>AcmeError</code></p> <p>External account binding is required.</p>"},{"location":"reference/gufo/acme/error/#gufo.acme.error.AcmeFulfillmentFailed","title":"<code>AcmeFulfillmentFailed</code>","text":"<p>               Bases: <code>AcmeError</code></p> <p>Failed to fulfill challenge.</p>"},{"location":"reference/gufo/acme/error/#gufo.acme.error.AcmeNotRegistredError","title":"<code>AcmeNotRegistredError</code>","text":"<p>               Bases: <code>AcmeError</code></p> <p>Client is not registred.</p>"},{"location":"reference/gufo/acme/error/#gufo.acme.error.AcmeRateLimitError","title":"<code>AcmeRateLimitError</code>","text":"<p>               Bases: <code>AcmeError</code></p> <p>Request rate limit exceeded.</p>"},{"location":"reference/gufo/acme/error/#gufo.acme.error.AcmeTimeoutError","title":"<code>AcmeTimeoutError</code>","text":"<p>               Bases: <code>AcmeError</code></p> <p>Operation timed out.</p>"},{"location":"reference/gufo/acme/error/#gufo.acme.error.AcmeUnauthorizedError","title":"<code>AcmeUnauthorizedError</code>","text":"<p>               Bases: <code>AcmeError</code></p> <p>Request is not authorized.</p>"},{"location":"reference/gufo/acme/error/#gufo.acme.error.AcmeUndecodableError","title":"<code>AcmeUndecodableError</code>","text":"<p>               Bases: <code>AcmeError</code></p> <p>Cannot decode an error message.</p>"},{"location":"reference/gufo/acme/log/","title":"gufo.acme.log","text":"<p>logging utilities.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <p>Gufo ACME logger.</p>"},{"location":"reference/gufo/acme/types/","title":"gufo.acme.types","text":"<p>RFC-8555 compatible ACME protocol structures.</p>"},{"location":"reference/gufo/acme/types/#gufo.acme.types.AcmeAuthorization","title":"<code>AcmeAuthorization</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>ACME Authorization resource.</p> <p>Attributes:</p> Name Type Description <code>domain</code> <code>str</code> <p>Domain name.</p> <code>url</code> <code>str</code> <p>Authorization URL.</p>"},{"location":"reference/gufo/acme/types/#gufo.acme.types.AcmeAuthorizationStatus","title":"<code>AcmeAuthorizationStatus</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Authorization status response.</p> <p>Attributes:</p> Name Type Description <code>status</code> <code>str</code> <p>Current status.</p> <code>challenges</code> <code>List[AcmeChallenge]</code> <p>List of ACME challenge.</p>"},{"location":"reference/gufo/acme/types/#gufo.acme.types.AcmeChallenge","title":"<code>AcmeChallenge</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>ACME challenge resource.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>str</code> <p>Challenge type, i.e. <code>http-01</code>, <code>dns-01</code>, ...</p> <code>url</code> <code>str</code> <p>Challenge confirmation URL.</p> <code>token</code> <code>str</code> <p>Challenge token.</p>"},{"location":"reference/gufo/acme/types/#gufo.acme.types.AcmeDirectory","title":"<code>AcmeDirectory</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>ACME directory.</p> <p>ACME directory is the structure containing endpoint urls for given server.</p> <p>Attributes:</p> Name Type Description <code>new_account</code> <code>str</code> <p>URL to create new account.</p> <code>new_nonce</code> <code>Optional[str]</code> <p>URL to get a new nonce.</p> <code>new_order</code> <code>str</code> <p>URL to create a new order.</p> <code>external_account_required</code> <code>bool</code> <p>True, if new_account requires external account binding.</p>"},{"location":"reference/gufo/acme/types/#gufo.acme.types.AcmeOrder","title":"<code>AcmeOrder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>ACME order resource.</p> <p>Attributes:</p> Name Type Description <code>authorizations</code> <code>List[AcmeAuthorization]</code> <p>List of possibile authirizations.</p> <code>finalize</code> <code>str</code> <p>URL to finalize the order.</p>"},{"location":"reference/gufo/acme/types/#gufo.acme.types.ExternalAccountBinding","title":"<code>ExternalAccountBinding</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>External account binding for .new_account() method.</p> <p>Attributes:</p> Name Type Description <code>kid</code> <code>str</code> <p>Key identifier.</p> <code>hmac_key</code> <code>bytes</code> <p>Decoded HMAC key.</p>"},{"location":"reference/gufo/acme/clients/","title":"gufo.acme.clients","text":"<p>Various ACME clients implementations.</p> <p>The following clients are provided out-of-the-box:</p> <ul> <li>base - Base class</li> <li>dav - http-01 WebDAV fulfillment.</li> <li>powerdns - dns-01 PowerDNS fulfillment.</li> <li>web - http-01 static file fulfillment.</li> </ul>"},{"location":"reference/gufo/acme/clients/base/","title":"gufo.acme.clients.base","text":"<p>An AcmeClient implementation.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient","title":"<code>AcmeClient</code>","text":"<p>               Bases: <code>object</code></p> <p>ACME Client.</p> <p>Examples: Create new account: <pre><code>async with AcmeClient(directory, key=key) as client:\n    uri = await client.new_account(\"test@example.com\")\n</code></pre> Sign an CSR: <pre><code>class SignClient(AcmeClient):\n    async def fulfill_http_01(\n        self, domain: str, challenge: AcmeChallenge\n    ) -&gt; bool:\n        # do something useful\n        return True\n\nasync with SignClient(directory, key=key, account_url=uri) as client:\n    cert = await client.sign(\"example.com\", csr)\n</code></pre></p> <p>Attributes:</p> Name Type Description <code>JOSE_CONTENT_TYPE</code> <code>str</code> <p>Content type for JOSE requests.</p> <code>NONCE_HEADER</code> <code>str</code> <p>Name of the HTTP response header containing nonce.</p> <code>RETRY_AFTER_HEADER</code> <code>str</code> <p>Name of the HTTP reponse header containing required retry delay.</p> <code>DEFAULT_TIMEOUT</code> <code>float</code> <p>Default network requests timeout, in seconds.</p> <p>Parameters:</p> Name Type Description Default <code>directory_url</code> <code>str</code> <p>An URL to ACME directory.</p> required <code>key</code> <code>JWK</code> <p>JWK private key. The compatible key may be generated by the gufo.acme.clients.base.AcmeClient.get_key function.</p> required <code>alg</code> <code>Optional[JWASignature]</code> <p>Signing algorithm to use.</p> <code>None</code> <code>account_url</code> <code>Optional[str]</code> <p>Optional ACME account URL, cotaining the stored result of the previous call to the gufo.acme.clients.base.AcmeClient.new_account function.</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>Network requests timeout in seconds.</p> <code>None</code> <code>user_agent</code> <code>Optional[str]</code> <p>Override default User-Agent header.</p> <code>None</code>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>An asynchronous context manager.</p> <p>Examples:</p> <pre><code>async with AcmeClient(....) as client:\n    ...\n</code></pre>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.__aexit__","title":"<code>__aexit__(exc_t, exc_v, exc_tb)</code>  <code>async</code>","text":"<p>Asynchronous context exit.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.clear_challenge","title":"<code>clear_challenge(domain, challenge)</code>  <code>async</code>","text":"<p>Clear up fulfillment after the challenge has been validated.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name.</p> required <code>challenge</code> <code>AcmeChallenge</code> <p>AcmeChallenge instance.</p> required"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.clear_dns_01","title":"<code>clear_dns_01(domain, challenge)</code>  <code>async</code>","text":"<p>Clear up fulfillment after the <code>dns-01</code> has been validated.</p> <p>Should be overriden in the subclasses to perform the real job.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name.</p> required <code>challenge</code> <code>AcmeChallenge</code> <p>AcmeChallenge instance.</p> required"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.clear_http_01","title":"<code>clear_http_01(domain, challenge)</code>  <code>async</code>","text":"<p>Clear up fulfillment after the <code>http-01</code> has been validated.</p> <p>Should be overriden in the subclasses to perform the real job.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name.</p> required <code>challenge</code> <code>AcmeChallenge</code> <p>AcmeChallenge instance.</p> required"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.clear_tls_alpn_01","title":"<code>clear_tls_alpn_01(domain, challenge)</code>  <code>async</code>","text":"<p>Clear up fulfillment after the <code>tls-alpn-01</code> has been validated.</p> <p>Should be overriden in the subclasses to perform the real job.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name.</p> required <code>challenge</code> <code>AcmeChallenge</code> <p>AcmeChallenge instance.</p> required"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.deactivate_account","title":"<code>deactivate_account()</code>  <code>async</code>","text":"<p>Deactivate account.</p> <p>Performs RFC-8555 pp. 7.3.6 call to deactivate an account. A deactivated account can no longer request certificate issuance or access resources related to the account, such as orders or authorizations.</p> <p>To call <code>deactivate_account</code> AcmeClient must be bound to acount either via <code>account_url</code> option or via <code>new_account</code> call. After successfully processing a client will be unbound from account.</p> <p>Examples:</p> <p>Deactivate account:</p> <pre><code>async with AcmeClient(\n    directory, key=key,\n    account_url=url\n) as client:\n    uri = await client.deactivate_account()\n</code></pre> <p>Raises:</p> Type Description <code>AcmeError</code> <p>In case of the errors.</p> <code>AcmeNotRegistred</code> <p>If the client is not bound to account.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.decode_auto_base64","title":"<code>decode_auto_base64(data)</code>  <code>staticmethod</code>","text":"<p>Decode Base64/Base64 URL.</p> <p>Auto-detect encoding.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Encoded text.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Decoded bytes.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.finalize_and_wait","title":"<code>finalize_and_wait(order, *, csr)</code>  <code>async</code>","text":"<p>Send finalization request and wait for the certificate.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>AcmeOrder</code> <p>ACME Order.</p> required <code>csr</code> <code>bytes</code> <p>CSR in PEM format.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>Signed certificate in PEM format.</p> <p>Raises:</p> Type Description <code>AcmeCertificateError</code> <p>When server refuses to sign the certificate.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.from_state","title":"<code>from_state(state, **kwargs)</code>  <code>classmethod</code>","text":"<p>Restore AcmeClient from the state.</p> <p>Restore the state of client from result of AcmeClient.get_state call.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bytes</code> <p>Stored state.</p> required <code>kwargs</code> <code>Any</code> <p>An additional arguments to be passed to constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>CT</code> <p>New AcmeClient instance.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.fulfill_challenge","title":"<code>fulfill_challenge(domain, challenge)</code>  <code>async</code>","text":"<p>Try to fulfill challege.</p> <p>Passes call to underlying <code>fulfill_*</code> function depending on the challenge type.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name.</p> required <code>challenge</code> <code>AcmeChallenge</code> <p>AcmeChallenge instance.</p> required <p>Returns:</p> Name Type Description <code>True</code> <code>bool</code> <p>if the challenge is fulfilled.</p> <code>False</code> <code>bool</code> <p>when failed to fulfill the challenge.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.fulfill_dns_01","title":"<code>fulfill_dns_01(domain, challenge)</code>  <code>async</code>","text":"<p>Fulfill the <code>dns-01</code> type of challenge.</p> <p>Should be overriden in subclasses to perform all necessary jobs. Override clear_dns_01 to perform cleanup.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name.</p> required <code>challenge</code> <code>AcmeChallenge</code> <p>AcmeChallenge instance.</p> required <p>Returns:</p> Name Type Description <code>True</code> <code>bool</code> <p>if the challenge is fulfilled.</p> <code>False</code> <code>bool</code> <p>when failed to fulfill the challenge.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.fulfill_http_01","title":"<code>fulfill_http_01(domain, challenge)</code>  <code>async</code>","text":"<p>Fulfill the <code>http-01</code> type of challenge.</p> <p>Should be overriden in subclasses to perform all necessary jobs. Override clear_http_01 to perform cleanup.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name.</p> required <code>challenge</code> <code>AcmeChallenge</code> <p>AcmeChallenge instance.</p> required <p>Returns:</p> Name Type Description <code>True</code> <code>bool</code> <p>if the challenge is fulfilled.</p> <code>False</code> <code>bool</code> <p>when failed to fulfill the challenge.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.fulfill_tls_alpn_01","title":"<code>fulfill_tls_alpn_01(domain, challenge)</code>  <code>async</code>","text":"<p>Fulfill the <code>tls-alpn-01</code> type of challenge.</p> <p>Should be overriden in subclasses to perform all necessary jobs. Override clear_tls_alpn_01 to perform cleanup.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name.</p> required <code>challenge</code> <code>AcmeChallenge</code> <p>AcmeChallenge instance.</p> required <p>Returns:</p> Name Type Description <code>True</code> <code>bool</code> <p>if the challenge is fulfilled.</p> <code>False</code> <code>bool</code> <p>when failed to fulfill the challenge.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.get_authorization_status","title":"<code>get_authorization_status(auth)</code>  <code>async</code>","text":"<p>Get an authorization status.</p> <p>Performs RFC-8555 pp. 7.5 sequence.</p> <p>Examples:</p> <pre><code>async with AcmeClient(\n    directory,\n    key=key,\n    account_url=account_url\n) as client:\n    order = await client.new_order([\n        \"example.com\",\n        \"sub.example.com\"\n    ])\n    for auth in order.authorizations:\n        auth_status = await client.get_authorization_status(auth)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>auth</code> <code>AcmeAuthorization</code> <p>AcmeAuthorization object, usually from AcmeOrder.authorizations.</p> required <p>Returns:</p> Type Description <code>AcmeAuthorizationStatus</code> <p>List of AcmeChallenge.</p> <p>Raises:</p> Type Description <code>AcmeError</code> <p>In case of the errors.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.get_domain_csr","title":"<code>get_domain_csr(domain, private_key)</code>  <code>staticmethod</code>","text":"<p>Generate CSR for domain in PEM format.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name.</p> required <code>private_key</code> <code>bytes</code> <p>Private key in PEM format. <code>get_domain_private_key</code> may be used to generate one.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>CSR in PEM format.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.get_domain_private_key","title":"<code>get_domain_private_key(key_size=4096)</code>  <code>staticmethod</code>","text":"<p>Generate private key for domain in PEM format.</p> <p>Parameters:</p> Name Type Description Default <code>key_size</code> <code>int</code> <p>RSA key size.</p> <code>4096</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Private key in PEM format.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.get_key","title":"<code>get_key()</code>  <code>staticmethod</code>","text":"<p>Generate account key.</p> <p>Examples:</p> <pre><code>key = AcmeClient.get_key()\n</code></pre> <p>Returns:</p> Type Description <code>JWKRSA</code> <p>A key which can be used as <code>key</code> parameter to constructor.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.get_key_authorization","title":"<code>get_key_authorization(challenge)</code>","text":"<p>Calculate value for key authorization.</p> <p>According to RFC-8555 pp. 8.1. Should be used in <code>fulfill_*</code> functions.</p> <p>Parameters:</p> Name Type Description Default <code>challenge</code> <code>AcmeChallenge</code> <p>ACME challenge.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>content of the key to be returned during challenge.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.get_self_signed_certificate","title":"<code>get_self_signed_certificate(csr, private_key, /, validity_days=365)</code>  <code>staticmethod</code>","text":"<p>Self-sign CSR and return certificate in PEM format.</p> <p>Parameters:</p> Name Type Description Default <code>csr</code> <code>bytes</code> <p>CSR in PEM format.</p> required <code>private_key</code> <code>bytes</code> <p>Private key in PEM format.</p> required <code>validity_days</code> <code>int</code> <p>Number of days the certificate is valid.</p> <code>365</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Self-signed certificate in PEM format.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.get_state","title":"<code>get_state()</code>","text":"<p>Serialize the state of client to a stream of bytes.</p> <p>The state will contain all necessasy information to instantiate the new client by the <code>AcmeClient.from_state(...)</code></p> Return <p>State of the client as a stream of bytes</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.is_bound","title":"<code>is_bound()</code>","text":"<p>Check if the client is bound to the account.</p> <p>The client may be bound to account either:</p> <ul> <li>By setting <code>account_url</code> in constructor.</li> <li>By calling gufo.acme.clients.base.AcmeClient.new_account</li> </ul> <p>Returns:</p> Type Description <code>bool</code> <p>True - if the client is bound to account, False - otherwise.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.new_account","title":"<code>new_account(email, *, external_binding=None)</code>  <code>async</code>","text":"<p>Create new account.</p> <p>Performs RFC-8555 pp. 7.3 call to create new account. The account will be bind to the used key.</p> <p>Examples:</p> <p>Create an account with single contact email:</p> <pre><code>async with AcmeClient(directory, key=key) as client:\n    uri = await client.new_account(\"test@example.com\")\n</code></pre> <p>Create an account with multiple contact emails:</p> <pre><code>async with AcmeClient(directory, key=key) as client:\n    uri = await client.new_account([\n        \"ca@example.com\",\n        \"boss@example.com\"\n    ])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>Union[str, Iterable[str]]</code> <p>String containing email or any iterable yielding emails.</p> required <code>external_binding</code> <code>Optional[ExternalAccountBinding]</code> <p>External account binding, if required.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>ACME account url which can be passed as <code>account_url</code> parameter to the ACME client.</p> <p>Raises:</p> Type Description <code>AcmeError</code> <p>In case of the errors.</p> <code>AcmeAlreadyRegistered</code> <p>If an client is already bound to account.</p> <code>AcmeExternalAccountRequred</code> <p>External account binding is required.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.new_order","title":"<code>new_order(domain)</code>  <code>async</code>","text":"<p>Create new order.</p> <p>Performs RFC-8555 pp. 7.4 order creation sequence. Before creating a new order any of the prerequisites must be met.</p> <ul> <li><code>new_accout()</code> function called.</li> <li><code>account_url</code> passed to constructor.</li> </ul> <p>Examples:</p> <p>Order for single domain:</p> <pre><code>async with AcmeClient(\n    directory,\n    key=key,\n    account_url=account_url\n) as client:\n    order = await client.new_order(\"example.com\")\n</code></pre> <p>Order for multiple domains:</p> <pre><code>async with AcmeClient(\n    directory,\n    key=key,\n    account_url=account_url\n) as client:\n    order = await client.new_order([\n        \"example.com\",\n        \"sub.example.com\"\n    ])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Union[str, Iterable[str]]</code> <p>String containing domain or an iterable yielding domains.</p> required <p>Returns:</p> Type Description <code>AcmeOrder</code> <p>An AcmeOrder object.</p> <p>Raises:</p> Type Description <code>AcmeError</code> <p>In case of the errors.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.respond_challenge","title":"<code>respond_challenge(challenge)</code>  <code>async</code>","text":"<p>Respond to challenge.</p> <p>Responding to challenge means the client performed all fulfillment tasks and ready to prove the challenge.</p> <p>Parameters:</p> Name Type Description Default <code>challenge</code> <code>AcmeChallenge</code> <p>ACME challenge as returned by <code>get_authorization_status</code> function.</p> required"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.sign","title":"<code>sign(domain, csr)</code>  <code>async</code>","text":"<p>Sign the CSR and get a certificate for domain.</p> <p>An orchestration function to perform full ACME sequence, starting from order creation and up to the certificate fetching.</p> <p>Should be used inn subclasses which override one or more of <code>fulfull_*</code> functions, and, optionaly, <code>clean_*</code> functions.</p> <p>Examples:</p> <pre><code>class SignClient(AcmeClient):\n    async def fulfill_http_01(\n        self, domain: str, challenge: AcmeChallenge\n    ) -&gt; bool:\n        # do something useful\n        return True\n\nasync with SignClient(\n    directory,\n    key=key,\n    account_url=uri\n) as client:\n    cert = await client.sign(\"example.com\", csr)\n</code></pre> <p>Returns:</p> Type Description <code>bytes</code> <p>The signed certificate in PEM format.</p> <p>Raises:</p> Type Description <code>AcmeTimeoutError</code> <p>On timeouts.</p> <code>AcmeFulfillmentFailed</code> <p>If the client failed to fulfill any challenge.</p> <code>AcmeError</code> <p>and subclasses in case of other errors.</p>"},{"location":"reference/gufo/acme/clients/base/#gufo.acme.clients.base.AcmeClient.wait_for_authorization","title":"<code>wait_for_authorization(auth)</code>  <code>async</code>","text":"<p>Wait untill authorization became valid.</p> <p>Parameters:</p> Name Type Description Default <code>auth</code> <code>AcmeAuthorization</code> <p>ACME Authorization</p> required"},{"location":"reference/gufo/acme/clients/dav/","title":"gufo.acme.clients.dav","text":"<p>A DavAcmeClient implementation.</p>"},{"location":"reference/gufo/acme/clients/dav/#gufo.acme.clients.dav.DavAcmeClient","title":"<code>DavAcmeClient</code>","text":"<p>               Bases: <code>AcmeClient</code></p> <p>WebDAV-compatible ACME Client.</p> <p>Fulfills http-01 challenge by uploading a token using HTTP PUT/DELETE methods with basic authorization. Works either with WebDAV modules or with custom scripts.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>DAV user name.</p> required <code>password</code> <code>str</code> <p>DAV password.</p> required"},{"location":"reference/gufo/acme/clients/dav/#gufo.acme.clients.dav.DavAcmeClient.clear_http_01","title":"<code>clear_http_01(domain, challenge)</code>  <code>async</code>","text":"<p>Remove provisioned token.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name</p> required <code>challenge</code> <code>AcmeChallenge</code> <p>AcmeChallenge instance, containing token.</p> required <p>Raises:</p> Type Description <code>AcmeFulfillmentFailed</code> <p>On error.</p>"},{"location":"reference/gufo/acme/clients/dav/#gufo.acme.clients.dav.DavAcmeClient.fulfill_http_01","title":"<code>fulfill_http_01(domain, challenge)</code>  <code>async</code>","text":"<p>Perform http-01 fullfilment.</p> <p>Execute PUT method to place a token.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name</p> required <code>challenge</code> <code>AcmeChallenge</code> <p>AcmeChallenge instance, containing token.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True - on succeess</p> <p>Raises:</p> Type Description <code>AcmeFulfillmentFailed</code> <p>On error.</p>"},{"location":"reference/gufo/acme/clients/dav/#gufo.acme.clients.dav.DavAcmeClient.get_auth","title":"<code>get_auth()</code>","text":"<p>Get Auth for request.</p> <p>Returns:</p> Type Description <code>AuthBase</code> <p>Auth information to be sent along with</p> <code>AuthBase</code> <p>the request.</p>"},{"location":"reference/gufo/acme/clients/powerdns/","title":"gufo.acme.clients.powerdns","text":"<p>A PowerDnsAcmeClient implementation.</p>"},{"location":"reference/gufo/acme/clients/powerdns/#gufo.acme.clients.powerdns.PowerDnsAcmeClient","title":"<code>PowerDnsAcmeClient</code>","text":"<p>               Bases: <code>AcmeClient</code></p> <p>PowerDNS compatible ACME Client.</p> <p>Fulfills dns-01 challenge by manipulating DNS RR via PowerDNS API.</p> <p>Parameters:</p> Name Type Description Default <code>api_url</code> <code>str</code> <p>Root url of the PowerDNS web.</p> required <code>api_key</code> <code>str</code> <p>PowerDNS API key.</p> required"},{"location":"reference/gufo/acme/clients/powerdns/#gufo.acme.clients.powerdns.PowerDnsAcmeClient.fulfill_dns_01","title":"<code>fulfill_dns_01(domain, challenge)</code>  <code>async</code>","text":"<p>Fulfill dns-01 challenge.</p> <p>Update token via PowerDNS API.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name</p> required <code>challenge</code> <code>AcmeChallenge</code> <p>AcmeChallenge instance, containing token.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True - on succeess.</p> <p>Raises:</p> Type Description <code>AcmeFulfillmentFailed</code> <p>On error.</p>"},{"location":"reference/gufo/acme/clients/web/","title":"gufo.acme.clients.web","text":"<p>A WebAcmeClient implementation.</p>"},{"location":"reference/gufo/acme/clients/web/#gufo.acme.clients.web.WebAcmeClient","title":"<code>WebAcmeClient</code>","text":"<p>               Bases: <code>AcmeClient</code></p> <p>A webserver-backed ACME client.</p> <p>Fulfills http-01 challenge by creating and removing token files in predefined directories.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path mapped to /.well-known/acme-challenges directory.</p> required"},{"location":"reference/gufo/acme/clients/web/#gufo.acme.clients.web.WebAcmeClient.clear_http_01","title":"<code>clear_http_01(domain, challenge)</code>  <code>async</code>","text":"<p>Remove provisioned token.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name</p> required <code>challenge</code> <code>AcmeChallenge</code> <p>AcmeChallenge instance, containing token.</p> required <p>Raises:</p> Type Description <code>AcmeFulfillmentFailed</code> <p>On error.</p>"},{"location":"reference/gufo/acme/clients/web/#gufo.acme.clients.web.WebAcmeClient.fulfill_http_01","title":"<code>fulfill_http_01(domain, challenge)</code>  <code>async</code>","text":"<p>Perform http-01 fullfilment.</p> <p>Put token to / file. <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain name</p> required <code>challenge</code> <code>AcmeChallenge</code> <p>AcmeChallenge instance, containing token.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True - on succeess</p> <p>Raises:</p> Type Description <code>AcmeFulfillmentFailed</code> <p>On error.</p>"}]}